#!/usr/bin/ruby


# -------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------ [Time]
# -------------------------------------------------------------------------------------------

class Time
  def self.genesis
    self.new(0)
  end

  def self.apocalypse
    self.new(2038)
  end
end


# -------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------- [XivelyClient]
# -------------------------------------------------------------------------------------------

require 'xively-rb'

class XivelyClient
  def initialize
    @client = Xively::Client.new $config[:xively_apikey]
    @url = "/v2/feeds/#{$config[:xively_feed]}"
  end
  def put(stream, value)
    $logger.debug "putting data {#{stream}=>#{value}} to xively"
    json = { :version => "1.0.0", :datastreams => [ {:id => stream, :current_value => value} ] }.to_json
    begin
      response = @client.put @url, :body => json
    rescue => e
      $logger.error "can't put in xivelyclient, #{e}"
    end
    $logger.debug response
  end
end


# -------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------- [Valves]
# -------------------------------------------------------------------------------------------

require 'wiringpi'

class Valves
  # For connections between RPi and OSpi, see
  # http://rayshobby.net/wordpress/wp-content/uploads/2013/02/ospi_diagram_connection.jpg
  # and for translations between header pins and wiringpi pins numbers, see
  # http://wiringpi.com/pins/
  STORE_PIN =  3 # 15 #&Device::BCM2835::RPI_GPIO_P1_15; # Latch D7 -> ST_CP 12 (storage clock)
  DATA_PIN  =  2 # 13 #&Device::BCM2835::RPI_GPIO_P1_13; # Data  D5 -> DS    14 (data in)
  NOE_PIN   =  0 # 11 #&Device::BCM2835::RPI_GPIO_P1_11; # ~OE   A1 -> ~OE   13 (not output enable)
  SHIFT_PIN =  7 #  7 #&Device::BCM2835::RPI_GPIO_P1_07; # Clock D6 -> SH_CP 11 (shift clock)
  #                                                 # connect rPi 2 5v  to VCC 16
  #                                                 # connect rPi 6 GND to GND  8
  #                                                 # connect rPi 6 GND to ~OE 13 (output enable, active low) to ground

  # Connect the shift register pins to these GPIO pins.
  def initialize
    @gpio = nil
    @on = 0

    return if # $DEBUG ||
              RUBY_PLATFORM != 'arm-linux-eabihf'

    @gpio = WiringPi::GPIO.new
    [DATA_PIN, SHIFT_PIN, STORE_PIN, NOE_PIN].each { |pin| @gpio.mode pin, OUTPUT }
    [DATA_PIN, SHIFT_PIN, STORE_PIN, NOE_PIN].each { |pin| @gpio.write pin, 0 }

    self.stop
  end

  def on
    return @on
  end

  def off?
    return @on == 0
  end

  def commit
    if @gpio
      $logger.info "committing valves"

      @gpio.write SHIFT_PIN, 0
      @gpio.write STORE_PIN, 0
      8.downto(1) do |ii|
        @gpio.write SHIFT_PIN, 0
        @gpio.write DATA_PIN, @on == ii ? 1 : 0
        @gpio.write SHIFT_PIN, 1
      end
      @gpio.write STORE_PIN, 1

      8.downto(1) do |ii|
        $xively.put "valve.#{ii}", @on == ii ? 1 : 0
      end
    end
  end

  def advance
    $semaphore.synchronize {
      loop do
        @on += 1
        break if @on > $config[:valve_specs].length || $config[:valve_specs][@on-1][:duration]
      end

      if @on > $config[:valve_specs].length
        $logger.info 'valve schedule complete'
        @on = 0
        $trigger = Time.apocalypse
      else
        $logger.info "advancing to run valve #{@on} - '#{$config[:valve_specs][@on-1][:name]}' for #{$config[:valve_specs][@on-1][:duration]} minutes"
        $trigger = Time.now + $config[:valve_specs][@on-1][:duration] * 60 # duration in seconds
      end
    }

    commit
  end

  def start valve
    $semaphore.synchronize {
      @on = valve
      if @on > $config[:valve_specs].length || @on < 0
        $logger.info "valve #{@on} out of range"
        @on = 0
        $trigger = Time.apocalypse
      else
        $logger.info "starting to run valve #{@on} - '#{$config[:valve_specs][@on-1][:name]}' for #{$config[:valve_specs][@on-1][:duration]} minutes"
        $trigger = Time.now + $config[:valve_specs][@on-1][:duration] * 60 # duration in seconds
      end
    }

    commit
  end

  def stop
    $logger.info 'stopping valves'
    $semaphore.synchronize {
      @on = 0
      $trigger = Time.apocalypse
    }
    commit
  end
end


# -------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------- [OAuth]
# -------------------------------------------------------------------------------------------

require 'google/api_client' # see http://code.google.com/p/google-api-ruby-client/
require 'yaml'

module OAuth
  class Google
    @@config_file = nil
    ['~/.google-api.yaml',
     '/etc/google-api.yaml'].each { |file|
      begin
        @@config_file = File.expand_path file
        break if File.exist? @@config_file
      rescue
        next
      end
    }
    class << self
      def load
        if File.exist? @@config_file
          return YAML.load_file @@config_file
        else
          warn "#@@config_file not found"
          self.abort_config_needed
        end
      end

      def abort_config_needed
        abort <<INTRO_TO_AUTH
    This utility requires valid oauth credentials and token for your project in the
    config file '#@@config_file'.

    You can create it by jumping through some oauth hoops by setting up a project and then
    using the google-api command, provided by the google-api-client gem:

    - Go to Google API Console at https://code.google.com/apis/console/ and set up a project
      that you will use to access this data.
     - In the "API Access" section, in the list of "Redirect URIs" include
       'http://localhost:12736/'.
     - Get your project's CLIENT_ID and CLIENT_SECRET to use below.

    - Users (including you) will need to grant permissions to access their calendars.
     - Generate the config file '#@@config_file' by calling the following, which will launch
       the browser and write the config file:
    (LD_LIBRARY_PATH=
     CLIENT_ID=[YOUR-CLIENT_ID]
     CLIENT_SECRET=[YOUR-CLIENT-SECRET]
     google-api oauth-2-login --scope=https://www.googleapis.com/auth/calendar --client-id="$CLIENT_ID" --client-secret="$CLIENT_SECRET" )
INTRO_TO_AUTH
      end
    end
  end
end


# -------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------- [Calendar]
# -------------------------------------------------------------------------------------------

module Calendar
  class GoogleAPIClient < ::Google::APIClient
    attr_reader :client
    def initialize oauth
      super({:application_name=>'flud', :application_version=>'2.0'})
      authorization.client_id     = oauth["client_id"]
      authorization.client_secret = oauth["client_secret"]
      authorization.scope         = oauth["scope"]
      authorization.refresh_token = oauth["refresh_token"]
      authorization.access_token  = oauth["access_token"]

      # NB: seems authorization.expired? does not work b/c times are not stored
      # in the yaml -- so we just call authorization.fetch_access_token! on error
      # see update_token! in http://code.google.com/p/google-api-ruby-client/wiki/OAuth2
      #if authorization.refresh_token && authorization.expired?
      #  authorization.fetch_access_token!
      #end
    end

    def fetch_data_with_retry api_method, params
      data = execute_aux(api_method, params).data
      if data_error data # try refereshing the access token and updating the data
        authorization.fetch_access_token!
        data = execute_aux(api_method, params).data
      end
      if err = data_error(data) # raise exception if still an error
        raise RuntimeError, err.to_json
      end
      return data
    end

    private
    def execute_aux api_method, params
      execute :api_method => api_method, :parameters => params
    end

    def data_error data
      if data.nil?
        return "data is nil"
      end
      data.to_hash["error"]
    end
  end


  class GoogleCalendarClient < GoogleAPIClient
    def events query
      Enumerator.new {|y| events_aux(query){|event| y << event}}
    end

    private
    def events_aux cal_query, &block # requires a block
      data = list_events cal_query
      data.items.each &block
#      if page_token = data.next_page_token
#        events_aux(cal_query.merge(:pageToken => page_token), &block)
#      end
    end

    # Params are as described in:
    # https://developers.google.com/google-apps/calendar/v3/reference/events/list
    def list_events params
      fetch_data_with_retry calendar_service.events.list, params
    end

    def calendar_service
      discovered_api 'calendar', 'v3'
    end
  end
end


# -------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------ [Updateable]
# -------------------------------------------------------------------------------------------

class Updateable
  def initialize
    $logger.debug "initializing #{self.class}"
    @update_interval = 0
    @last_check = Time.genesis
  end

  def update_interval
    @update_interval
  end

  def last_check
    @last_check
  end

  def freshen
    @last_check = Time.now
  end

  def is_stale?
    $logger.debug "checking whether #{self.class} (#{last_check}, #{update_interval}) is stale"
    Time.now - last_check >= update_interval
  end
end


# -------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------- [CalendarClient]
# -------------------------------------------------------------------------------------------

class CalendarClient < Updateable
  def initialize
    super
    @update_interval = 15 * 60 # seconds
    @cal = Calendar::GoogleCalendarClient.new OAuth::Google.load
  end

  def trigger
    trigger = Time.apocalypse
    $logger.info "retrieving google calendar"
    @query = {:calendarId   => $config[:calendar_id],
              :timeMin      => (Time.now -     update_interval).iso8601,
              :timeMax      => (Time.now + 2 * update_interval).iso8601,
              :singleEvents => "true",
              :orderBy      => "startTime",
              :maxResults   => 1,
              :sortOrder    => 'a'}
    begin
      events = @cal.events @query
      #events.each{|ev| puts ev['start']['dateTime'] }
      unless events.first.nil?
        trigger = events.first['start']['dateTime']
      end
    rescue => e
      $logger.error "couldn't get calendar, #{e}"
    end
    freshen
    $logger.info "trigger = #{trigger}"
    return trigger
  end
end


# -------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------- [WeatherClient]
# -------------------------------------------------------------------------------------------

require 'wunderground'

class WeatherClient < Updateable
  def initialize
    super
    @update_interval = 60 * 60 # seconds
    @weather = Wunderground.new $config[:wunderground_apikey]
  end

  def rainfall
    rainfall = 0
    if @weather
      $logger.info "retrieving weather for zipcode #{$config[:zipcode]}"
      begin
        data = @weather.forecast_for $config[:zipcode]
        #$logger.debug data;
        data['forecast']['simpleforecast']['forecastday'].each do |forecast|
          $logger.debug "#{forecast['date']['pretty']} => #{forecast['qpf_allday']['in']}"
          rainfall += forecast['qpf_allday']['in']
        end
      rescue => e
        $logger.error "couldn't get weather, #{e}"
      end
    end
    freshen
    $logger.info "rainfall = #{rainfall} in"
    $xively.put "forecast.rainfall", rainfall
    return rainfall
  end
end


# -------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------- [Status]
# -------------------------------------------------------------------------------------------

class Status < Updateable
  def initialize
    super
    @update_interval = 1 * 60 # seconds
  end

  def print
    current = Time.now
    if !$valves.off?
      $logger.debug "v#{$valves.on} #{Time.at($trigger - current).utc.strftime '%H:%M:%S'}"
    elsif $trigger > current
      $logger.debug "#{$rainfall} in #{Time.at($trigger - current).utc.strftime '%H:%M:%S'}"
    else
      $logger.debug "rainfall = #{$rainfall} in"
    end
    freshen
  end
end


# ------------------------------------------------------------------------------- [Webserver]
# -------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

require 'webrick'

class Webserver
  def initialize options
    @webserver = WEBrick::HTTPServer.new :Port => 8888, :Logger => $logger, :AccessLog => []
    @webserver.mount '/', Simple
  end

  def self.run! options
    Webserver.new(options).run!
  end

  def run!
    $logger.info "starting webserver"
    @webserver.start
  end
end

class Simple < WEBrick::HTTPServlet::AbstractServlet
  def encode_entities str
    str
  end

  def do_GET request, response
    $logger.info "webserver GET " + request.path
    case request.path
    when '/api/advance'
      do_api_advance request, response
    when '/api/stop'
      do_api_stop request, response
    when '/api/startValve'
      do_api_startValve request, response
    when '/api/getStatus'
      do_api_getStatus request, response
    when '/favicon.ico'
      response.status = 404
    when '/'
      do_index request, response
    end
  end

  def do_api_advance request, response
    $valves.advance
    response.status = 200
    response['Content-Type'] = 'text/html'
    response.body = "#{$valves.on}"
  end

  def do_api_stop request, response
    $valves.stop
    response.status = 200
    response['Content-Type'] = 'text/html'
    response.body = "#{$valves.on}"
  end

  def do_api_startValve request, response
    $valves.start request.query['valve'].to_i
    response.status = 200
    response['Content-Type'] = 'text/html'
    response.body = "#{$valves.on}"
  end

  def do_api_getStatus request, response
     response.status = 200
     response['Content-Type'] = 'text/json'
     response.body = {:timestamp => Time.now,
                      :trigger   => $trigger,
                      :rainfall  => $rainfall,
                      :moisture  => $moisture,
                      :voltage   => $voltage,
                      :dirtmon_timestamp => $dirtmon_timestamp,
                      :valveOn   => $valves.on}.to_json
  end

  def do_index request, response
    response.status = 200
    response['Content-Type'] = 'text/html'
    response.body = <<INDEX_HTML
      <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
      <script>
      function indicateValve (num) {
        $("div.running").hide ();
        $("div.running").filter (function (index) {return index + 1 == num;}).show ("fast");
      }
      function startValve (num) {
        $.ajax({
          url: "/api/startValve",
          data: {
            valve: num + 1
          },
          success: function (data) {
            $("#status").html ("<strong>success " + data + "</strong>");
            indicateValve (data);
          }
        });
      }
      function stop () {
        $.ajax({
          url: "/api/stop",
          success: function (data) {
            $("#status").html ("<strong>success " + data + "</strong>");
            indicateValve (data);
          }
        });
      }
      function advance () {
        $.ajax({
          url: "/api/advance",
          success: function (data) {
            $("#status").html ("<strong>success " + data + "</strong>");
            indicateValve (data);
          }
        });
      }
      function refreshStatus () {
        $.ajax({
          url: "/api/getStatus",
          dataType: "json",
          success: function (data) {
            $("#timestamp").html(data.timestamp);
            $("#trigger").html(data.trigger);
            $("#rainfall").html(data.rainfall);
            $("#moisture").html(data.moisture);
            $("#voltage").html(data.voltage);
            $("#dirtmon_timestamp").html(data.dirtmon_timestamp);
            indicateValve (data.valveOn);
          },
        });
      }
      $(document).ready(function () {
        refreshStatus ();
        setInterval (refreshStatus, 30 * 1000);
      });
      </script>
      <div id="status"></div>
      Server timestamp =    <div style="display:inline" id="timestamp">#{Time.now}</div><br>
      Next trigger =        <div style="display:inline" id="trigger">#{$trigger}</div><br>
      Forecasted rainfall = <div style="display:inline" id="rainfall">#{$rainfall}</div> in<br>
      Soil moisture =       <div style="display:inline" id="moisture">#{$moisture}</div><br>
      Sensor voltage =      <div style="display:inline" id="voltage">#{$voltage}</div>V<br>
      Dirtmon timestamp =   <div style="display:inline" id="dirtmon_timestamp">#{$dirtmon_timestamp}</div><br>
      <br>
      Valves <form method='POST'>
INDEX_HTML
    (0..($config[:valve_specs].length-1)).each do |ii|
      response.body += "<input type='text' name='n#{ii}' value='#{$config[:valve_specs][ii][:name]}' />" +
                       "<input type='text' name='d#{ii}' value='#{$config[:valve_specs][ii][:duration]}' />" +
                       "<input type='button' name='s#{ii}' value='start' onclick='startValve(#{ii})' />" +
                       "<div class='running' style='display:inline;'>&lt;-- ON</div>" +
                       "<br>"
    end
    response.body += "<input type='button' value='advance' onclick='advance()' />" +
                     "<input type='button' value='stop' onclick='stop()' />" +
                     "<br><br>" +
                     "Google calendar id  <input type='text' name='calendar_id'         value='#{$config[:calendar_id]}' /><br>" +
                     "Wunderground API key<input type='text' name='wunderground_apikey' value='#{$config[:wunderground_apikey]}' /><br>" +
                     "Zipcode             <input type='text' name='zipcode'             value='#{$config[:zipcode]}' /><br>" +
                     "Xively API key      <input type='text' name='xively_apikey'       value='#{$config[:xively_apikey]}' /><br>" +
                     "Xively feed id      <input type='text' name='xively_feed'         value='#{$config[:xively_feed]}' /><br>" +
                     "Rain threshold      <input type='text' name='rain_threshold'      value='#{$config[:rain_threshold]}' /><br>" +
                     "Moisture threshold  <input type='text' name='moisture_threshold'  value='#{$config[:moisture_threshold]}' /><br>" +
                     "<input type='hidden' name='h' />" +
                     "<input type='submit' value='Submit' /></form>"
  end

  def do_POST request, response
    $logger.info "webserver POST #{request.query}"
    request.query.each do |key, value|
      if index = /^n(\d+)/.match(key)
        $config[:valve_specs][index.captures[0].to_i][:name] = value.to_s
      elsif index = /^d(\d+)/.match(key)
        $config[:valve_specs][index.captures[0].to_i][:duration] = value.to_i
      elsif /_threshold/.match(key)
        $config[key.to_sym] = value.to_f
      else
        $config[key.to_sym] = value.to_s
      end
    end
    $config.write
    do_index request, response
  end
end


# -------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------- [Dirtmon]
# -------------------------------------------------------------------------------------------

require 'serialport'

class Dirtmon
  attr_reader :options, :quit

  def initialize options
    @options = options
    @port = '/dev/ttyUSB0'
    @baud_rate = 57600
    @data_bits = 8
    @stop_bits = 1
    @parity    = SerialPort::NONE
    #ob->handshake("none") || $log->logdie ("failed setting handshake")
  end

  def self.run! options
    Dirtmon.new(options).run!
  end

  def run!
    $logger.info 'dirtmon starting'
    SerialPort.open(@port, @baud_rate, @data_bits, @stop_bits, @parity) do |sp|
      sp.puts '1i 212g' # node 1 in group 212
      while !quit
        $logger.debug 'dirtmon listening'
        while message = sp.gets.chomp
          # byte -> 0  1  2  3  4  5  6   7   8  9  10  11  12
          #         ====  ----------  - --- ---  -----  ------
          # eg   -> OK 2  2  0  0  0  2 115 117  0   0   0   0
          #  long ping;      // 32-bit counter
          #  byte id :7;     // identity, should be different for each node
          #  byte boost :1;  // whether compiled for boost chip or not
          #  byte vcc1;      // VCC before transmit, 1.0V = 0 .. 6.0V = 250
          #  byte vcc2;      // battery voltage (BOOST=1), or VCC after transmit (BOOST=0)
          #  word sensor;    // sensor1
          #  word sensor;    // sensor2
          if message =~ /^OK 2/
            rec = message.split(' ').map{ |v| v.to_i }
            ping  = rec[2] + rec[3] * 256 + rec[4] * 256 * 256 + rec[5] * 256 * 256 * 256
            id    = rec[6]
            vcc1  = rec[7] / 250.0 * 5.0 + 1.0
            vcc2  = rec[8] / 250.0 * 5.0 + 1.0
            sensor1 = rec[9] + rec[10] * 256
            sensor2 = rec[11] + rec[12] * 256
            $logger.info ['dirtmon', ping, id, vcc1, vcc2, sensor1, sensor2].join(' ')
            $xively.put "dirtmon1.vcc1", vcc1
            $xively.put "dirtmon1.vcc2", vcc2
            $xively.put "dirtmon1.moisture1", sensor1
            $xively.put "dirtmon1.moisture2", sensor2
            $moisture = (sensor1 + sensor2) / 2
            $voltage  = (vcc1 + vcc2) / 2.0
            $dirtmon_timestamp = Time.now
          end
        end
        sleep 1
      end
    end
    $logger.info 'dirtmon exiting'
  end
end


# -------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------- [Config]
# -------------------------------------------------------------------------------------------


class Configuration
  attr_accessor :params

  def initialize locations
    @params = {:calendar_id         => nil,
               :wunderground_apikey => nil,
               :xively_feed         => nil,
               :xively_apikey       => nil,
               :zipcode             => nil,
               :rain_threshold      => nil,
               :moisture_threshold  => nil,
               :valve_specs         => (1..8).map{|v| {:name => "valve.#{v}", :duration => 1}}}

    locations.each { |file|
      if File.file? file
        @conf_file = file
        @params = YAML.load_file @conf_file
        break
      end
    }
    unless @conf_file
      @conf_file = locations[0]
      write
    end
  end

  def [](param)
    return self.params[param]
  end

  def []=(param, value)
    self.params[param] = value
  end

  def get_params
    return self.params.keys
  end

  def write
    $logger.info 'writing configuration file'
    File.open(@conf_file, 'w') do |file|
      file.write(YAML.dump @params)
    end
  end
end

$config = Configuration::new(["flud.yml", "/etc/flud.yml"])


class IOToLog < IO
  def initialize(logger)
    @logger = logger
  end

  def write(string)
    #assume anything written to stderr is an error
    @logger.error(message)
  end
end


# -------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------- [Server]
# -------------------------------------------------------------------------------------------

require 'fileutils'
require 'logger'

# server class from https://github.com/jakesgordon/ruby-sample-daemon/blob/master/lib/server.rb
class Server
  VERSION = "1.0.0"

  attr_reader :options, :quit

  def initialize options
    @options = options
    options[:logfile] = File.expand_path(logfile) if logfile?   # daemonization might change CWD so expand any relative paths in advance
    options[:pidfile] = File.expand_path(pidfile) if pidfile?   # (ditto)
  end

  def daemonize?
    !options[:foreground]
  end

  def logfile
    options[:logfile]
  end

  def pidfile
    options[:pidfile]
  end

  def logfile?
    !logfile.nil?
  end

  def pidfile?
    !pidfile.nil?
  end

  def info msg
    puts "[#{Process.pid}] [#{Time.now}] #{msg}"
  end

  #--------------------------------------------------------------------------

  def self.run! options
    Server.new(options).run!
  end

  def run!
    if daemonize? && Process.euid != 0
      puts "only root can daemonize, run with --foreground instead"
      exit
    end

    check_pid
    daemonize if daemonize?
    write_pid
    trap_signals

    if daemonize?
      redirect_output
    end
    $logger = Logger.new STDOUT
    $logger.level = $DEBUG ? Logger::DEBUG : Logger::INFO
    $logger.info 'starting'

    $semaphore = Mutex::new
    $xively    = XivelyClient::new
    $valves    = Valves::new
    $weather   = WeatherClient::new
    $calendar  = CalendarClient::new
    $status    = Status::new
    $trigger   = Time.apocalypse
    $rainfall  = 0
    $moisture  = 0
    $voltage   = 0
    $dirtmon_timestamp = Time.genesis

    Thread.new{Dirtmon.run! nil}
    Thread.new{Webserver.run! nil}

    while !quit do
      if $valves.off? && $weather.is_stale?
        $rainfall = $weather.rainfall
      elsif $valves.off? && $calendar.is_stale?
        $trigger = $calendar.trigger
      elsif $trigger < Time.now
        $logger.debug 'triggering'
        if !$valves.off? || ($rainfall <= $config[:rain_threshold] && $moisture <= $config[:moisture_threshold])
          $valves.advance
        else
          if $rainfall > $config[:rain_threshold]
            $logger.info "rainfall delay"
          elsif $moisture > $config[:moisture_threshold]
            $logger.info "moisture delay"
          end
          $trigger += $weather.update_interval
        end
      elsif $status.is_stale?
        $status.print
      end
      sleep 1
    end

    $valves.stop

    # Mark a clean exit in the log
    $logger.info 'exiting'
  end

  def daemonize
    exit if fork
    Process.setsid
    exit if fork
    Dir.chdir "/"
  end

  def redirect_output
    FileUtils.mkdir_p(File.dirname(logfile), :mode => 0755)
    FileUtils.touch logfile
    File.chmod 0644, logfile
    $stderr.reopen logfile, 'a'
    $stdout.reopen $stderr
    $stdout.sync = $stderr.sync = true
  end

  def suppress_output
    $stderr.reopen '/dev/null', 'a'
    $stdout.reopen $stderr
  end

  def write_pid
    if pidfile? && Process.euid == 0
      begin
        File.open(pidfile, ::File::CREAT | ::File::EXCL | ::File::WRONLY){|f| f.write "#{Process.pid}" }
        at_exit { File.delete(pidfile) if File.exists? pidfile }
      rescue Errno::EEXIST
        check_pid
        retry
      end
    end
  end

  def check_pid
    if pidfile?
      case pid_status pidfile
      when :running, :not_owned
        puts "A server is already running. Check #{pidfile}"
        exit 1
      when :dead
        File.delete pidfile
      end
    end
  end

  def pid_status pidfile
    return :exited unless File.exists? pidfile
    pid = ::File.read(pidfile).to_i
    return :dead if pid == 0
    Process.kill 0, pid
    :running
  rescue Errno::ESRCH
    :dead
  rescue Errno::EPERM
    :not_owned
  end

  def trap_signals
    trap(:INT)  do $logger.info 'caught SIGINT, exiting gracefully'  ; @quit = true; end
    trap(:QUIT) do $logger.info 'caught SIGQUIT, exiting gracefully' ; @quit = true; end
    trap(:TERM) do $logger.info 'caught SIGTERM, exiting gracefully' ; @quit = true; end
  end
end


# -------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------- [Options]
# -------------------------------------------------------------------------------------------

require 'optparse'

options = { :action => :run, :foreground => false, :logfile => '/var/log/flud.log', :pidfile => '/var/run/flud.pid' }

foreground_help = "don't daemonize (default: false)"
pidfile_help    = "the pid filename"
logfile_help    = "the log filename"
include_help    = "an additional $LOAD_PATH (may be used more than once)"
debug_help      = "set $DEBUG to true"
warn_help       = "enable warnings"

op = OptionParser.new
op.banner =  "flud control daemon"
op.separator ""
op.separator "Usage: flud [options]"
op.separator ""

op.separator ""
op.separator "Process options:"
op.on("-f", "--foreground",  foreground_help) {         options[:foreground] = true  }
op.on("-p", "--pid PIDFILE", pidfile_help)    { |value| options[:pidfile]    = value }
op.on("-l", "--log LOGFILE", logfile_help)    { |value| options[:logfile]    = value }

op.separator ""
op.separator "Ruby options:"
op.on("-I", "--include PATH", include_help) { |value| $LOAD_PATH.unshift(*value.split(":").map{|v| File.expand_path(v)}) }
op.on(      "--debug",        debug_help)   { $DEBUG = true }
op.on(      "--warn",         warn_help)    { $-w = true    }

op.separator ""
op.separator "Common options:"
op.on("-h", "--help")    { options[:action] = :help    }
op.on("-v", "--version") { options[:action] = :version }

op.separator ""
op.parse!(ARGV)


# -------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------- [Run]
# -------------------------------------------------------------------------------------------

case options[:action]
when :help    then puts op.to_s
when :version then puts Server::VERSION
else
  Server.run! options
end
